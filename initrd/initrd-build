#!/usr/bin/env python3
# Populate an initrd directory with programs and their libraries
import sys
import re
import os
from enum import IntEnum
import subprocess
import traceback

def die(s):
	print(s, file=sys.stderr)
	exit(1)
def system(*args):
	sub = subprocess.run(args, capture_output=True)
	if sub.returncode == 0:
		return sub.stdout
	print(sub.stderr, file=sys.stderr)
	return None

# mode includes
class CPIO_MODE(IntEnum):
	S_ISUID  = 0o4000   # Set uid
	S_ISGID  = 0o2000   # Set gid
	S_ISVTX  = 0o1000   # Save text (sticky bit)
	S_ISDIR  = 0o40000  # Directory
	S_ISFIFO = 0o10000  # FIFO
	S_ISREG  = 0o100000 # Regular file
	S_ISLNK  = 0o120000 # Symbolic link
	S_ISBLK  = 0o60000  # Block special file
	S_ISCHR  = 0o20000  # Character special file
	S_ISSOCK = 0o140000 # Socket

def cpio_hex(x):
	return ("%08x" % (x)).encode('utf-8')

# returns a blob formatted as a newc cpio entry
#       Field name    Field size	 Meaning
#       c_magic	      6 bytes		 The string "070701" or "070702"
#       c_ino	      8 bytes		 File inode number (always 0)
#       c_mode	      8 bytes		 File mode and permissions
#       c_uid	      8 bytes		 File uid
#       c_gid	      8 bytes		 File gid
#       c_nlink	      8 bytes		 Number of links (always 0)
#       c_mtime	      8 bytes		 Modification time (always 0)
#       c_filesize    8 bytes		 Size of data field
#       c_maj	      8 bytes		 Major part of file device number (always 0)
#       c_min	      8 bytes		 Minor part of file device number (always 0)
#       c_rmaj	      8 bytes		 Major part of device node reference
#       c_rmin	      8 bytes		 Minor part of device node reference
#       c_namesize    8 bytes		 Length of filename, including final \0
#       c_chksum      8 bytes		 Checksum of data field if c_magic is 070702;
				 #       otherwise zero
# followed by namesize bytes of name (padded to be a multiple of 4)
# followed dby filesize bytes of file (padded to be a multiple of 4)
#

def cpio_entry(filename, data, uid=0, gid=0, major=None, minor=None, mode=0o777):
	# remove any duplicate / and strip the leading /
	filename = re.sub(r'//*/', '/', filename)
	filename = re.sub(r'^/*', '', filename)
	name = filename.encode('utf-8') + b'\0'
	name_len = len(name) # including nul terminator
	data_len = len(data) # as is

	# pad filename so that it ends up aligned on a
	# four byte block. HOWEVER, it starts offset by 2,
	# so there is some weirdness here.  note that the
	# data is *NOT* padded here, since it will be
	# aligned during the final write out
	if (name_len+2) % 4 != 0:
		name += bytes(4 - ((name_len+2) % 4))

	# if major/minor are not set, then this is a regular file
	if mode & (CPIO_MODE.S_ISDIR | CPIO_MODE.S_ISBLK | CPIO_MODE.S_ISCHR) == 0:
		mode |= CPIO_MODE.S_ISREG
	if major is None:
		major = 0
		minor = 0

	return b'' \
		+ b'070701' \
		+ b'00000000' \
		+ cpio_hex(mode) \
		+ cpio_hex(uid) \
		+ cpio_hex(gid) \
		+ b'00000000' \
		+ b'00000000' \
		+ cpio_hex(data_len) \
		+ b'00000000' \
		+ b'00000000' \
		+ cpio_hex(major) \
		+ cpio_hex(minor) \
		+ cpio_hex(name_len) \
		+ b'00000000' \
		+ name \
		+ data


directories = {}
files = []

def cpio_mkdirs(dest):
	# strip any leading /
	dest = re.sub(r'^/*', '', dest)
	path = ''
	for subdir in re.split(r'/+', dest):
		if path == '':
			path = subdir
		else:
			path += '/' + subdir
		if path in directories:
			continue
		if path == '':
			continue
		files.append(cpio_entry(path, b'', mode = 0o777 | CPIO_MODE.S_ISDIR))
		directories[path] = 1

if len(sys.argv) < 3:
	die("Usage: initrd-build initrd.cpio files.txt [...]")


initrd_filename = sys.argv[1]
deps = open(initrd_filename + ".deps", "w")
if not deps:
	die(initrd_file + ".deps: Unable to create dependency file")

uname = system("uname", "-r")

print("# Autogenerated dependencies for " + initrd_filename, file=deps)


def process_line(line):
	words = re.split(r'\s+', line)
	if words[0] == "symlink":
		# the filename is the second part, the data in that
		# file is the path to the real file
		print("symlink %s -> %s" % (words[1], words[2]))
		files.append(cpio_entry(words[2], words[1].encode('utf-8'), mode = 0o777 | CPIO_MODE.S_ISLNK))
		return
	if words[0] == "mkdir":
		print("mkdir %s" % (words[1]))
		cpio_mkdirs(words[1])
		return
	if words[0] == "mknod":
		# TODO
		print("mknod %s %s %d %d")
		return

	# normal file
	filename = words[0]
	dest = "bin"
	if len(words) > 1:
		dest = words[1]

	# if the dest does not already exist, be sure to make it
	cpio_mkdirs(dest)

	# read in the data from the file
	mode = os.stat(filename).st_mode
	with open(filename, "rb") as datafile:
		data = datafile.read()

	# strip the local path
	dest_filename = os.path.basename(filename)

	print("add %s -> %s/%s (%d bytes)" % (filename, dest, dest_filename, len(data)))
	files.append(cpio_entry(dest + "/" + dest_filename, data, mode = mode))
	# todo: ldd stuff

for filename in sys.argv[2:]:
	with open(filename, "r") as f:
		linenum = 0
		for line in f.readlines():
			linenum += 1

			# strip any commands and skip blank lines
			line = re.sub(r'\n$', '', line)
			line = re.sub(r'^\s*', '', line)
			line = re.sub(r'\s*#.*$','', line)
			if len(line) == 0:
				continue

			print("%s:%d: %s" % (filename, linenum, line))

			try:
				process_line(line)
			except Exception as e:
				print("%s:%d: failed '%s'" % (filename, linenum, line), e, file=sys.stderr)
				print(traceback.format_exc())
				exit(1)


with open(initrd_filename, "wb") as initrd:
	total = 0
	for f in files:
		if total % 4 != 0:
			f = bytes(4 - total % 4) + f
		initrd.write(f)
		total += len(f)

	cpio_trailer = cpio_entry("TRAILER!!!", b'', mode=0)
	initrd.write(cpio_trailer)
	total += len(cpio_trailer)

	# pad to a full block size to make linux happy if
	# this is ever concatenated with another initrd
	if total % 512 != 0:
		initrd.write(bytes(512 - total % 512))

				
"""

	$dest ||= "/bin";
	print DEPS "\t$bin \\\n";

	system 'mkdir', '-p', "$top/$dest"
		and die "mkdir $top/$dest: $!\n";

	$bin =~ s/\$UNAME/$UNAME/g;

	cp($bin, "$top/$dest/" . basename($bin))
		or die "cp -r $bin $top/$dest/: Unable to copy: $!\n";

	my @deps = `ldd "$bin" 2>&1`
		or next;

	for (@deps)
	{
		chomp;
		next if m/not a dynamic executable/;

		my ($short,$lib,$addr) = /^
			\s+
			(.*?\s+=>\s+)?
			(.*?)
			\s+
			\((0x[0-9a-f]*)\)
			$/msgx
		or warn "$bin: unable to parse '$_'\n"
		and next;

		next if $lib =~ /^linux-vdso/;

		push @{ $libs{$lib} ||= [] }, $bin;
	}
}

system 'mkdir', '-p', "$lib_dir";

for my $lib (sort keys %libs)
{
	print "$lib: ", join(' ', @{$libs{$lib}}), "\n";
	print DEPS "\t$lib \\\n";

	cp($lib, "$lib_dir/" . basename($lib))
		or die "$lib: Unable to copy: $!\n";
}


print DEPS "\n";
close DEPS;
"""
